---
title: "Reproducing 2014 results in Stan- Part 1"
author: "Sean Raleigh"
date: "July 8, 2015"
output: html_document
---

To get Stan working, we reproduce the results from the 2014 report, except we convert everything from `lme4` to Stan. (This is Part 1: the file is split up to keep compilation managaeable.)

This part contains the complete pooling and no pooling models.

## Housekeeping

Load necessary libraries and special functions.

```{r, message = FALSE}
library(rstan)
library(parallel)
library(beepr)
library(dplyr)
library(ggplot2)
library(knitr)
library(readr)
```

```{r}
source("stan_utilities.R")

## The file stan_utilities.R contains the following functions:

########################################

## cleanup

## Cleans up the objects left over after fitting a Stan model:
##      data_model:     The data list passed to stan.
##      stan_model:     The model code as a character string.
##      fit_model:      The stanfit object output.
##      samples_model:  The samples as a data frame.
##      params_model:   The parameters to track for plotting.
## Returns nothing.

## cleanup(model)

# model:                Root name of the Stan model as character string.

########################################

## multiplot (winston Chang)

## Places ggplot objects in a grid.
## Returns nothing, but displays desired graphics.

## multiplot(..., plotlist=NULL, file, cols=1, layout=NULL)

# ...               One can pass ggplot objects directly.
#                           (But it's easier to pass them as a plotlist.)
# plotlist:         A list of ggplot objects.
# cols:             Number of columns in layout.
#                       If layout is not specified, multiplot will calculate
#                       how many rows to create using cols.
# layout:           A layout matrix.
#                       For example:
#                           matrix(c(1,2,3,3), nrow=2, byrow=TRUE)
#                       Plot 1 will go in the upper left,
#                       plot 2 will go in the upper right, and
#                       plot 3 will go all the way across the bottom.
#                       If present, cols is ignored.

########################################

## HDIofMCMC (John Kruschke)

## Computes highest density interval from a sample of representative values,
##      estimated as shortest credible interval.

## HDIofMCMC(sampleVec , cred_mass = 0.95)

# sampleVec:        A vector of representative values from a probability distribution.
# cred_mass:        A scalar between 0 and 1, indicating the mass within the credible
#                       interval that is to be estimated.

########################################

## HDI_calc

## Calculates HDI and prepares graphical parameters to pass to ggplot.
## Returns a list of three objects:
##      breaks:     The breaks to use for the histogram.
##      line_pos:   Parameters for plotting the HDI line segments.
##      text_pos:   Parameters for plotting the text annotations.

## HDI_calc(sample, cred_mass = 0.95, digits = 2)

# sample:           A vector of representative values from a probability distribution.
# cred_mass:        A scalar between 0 and 1, indicating the mass within the credible
#                       interval that is to be estimated.
# digits:           The number of decimal places when displaying the HDI.

########################################

## param_plot

## Plots a sampled parameter along with HDI.
## Returns a ggplot object.

## param_plot(sample, param, cred_mass = 0.95)

# sample:           A vector of representative values from a probability distribution.
# param:            A string with the name of the parameters to be plotted.
# cred_mass:        A scalar between 0 and 1, indicating the mass within the credible
#                       interval that is to be estimated.

########################################

## sample_plots

## Creates a grid of histograms of sampled parameters with HDIs.
## Returns nothing, but displays the result of multiplot.

## sample_plots(samples, params, cred_mass = 0.95, layout = NULL)

# samples:          A data frame extracted from a stanfit object.
# params:           A character vector of parameters to be plotted.
# cred_mass:        A scalar between 0 and 1, indicating the mass within the credible
#                       interval that is to be estimated.
# layout:           A layout matrix.
#                       For example:
#                           matrix(c(1,2,3,3), nrow=2, byrow=TRUE)
#                       Plot 1 will go in the upper left,
#                       plot 2 will go in the upper right, and
#                       plot 3 will go all the way across the bottom.
#                       If present, cols is ignored.

########################################

```

## Read and process data

Load data.

```{r}
natsap <- read_csv("AllClients_rev3.csv")
dose <- read_csv("DoseData_07-08-2015.csv")
```

Clean data.

```{r}

## Subset data

natsap_sub <- natsap %>%
    select(sex = gender,
           ID = programId,
           company = company,
           OQ_A = Z1_A0_Self_SCORE,
           OQ_D = Z1_D0_Self_SCORE)

dose_sub <- dose %>%
    select(company = company,
           ID = NATSAP_ID,
           RTCWT = `RTC or WT`,
           IT = `Mode minutes of Inidividual Therapy per week`,
           # IT_freq = `Frequency of IT per week`,
           GT = `Mode minutes of Group Therapy per week`,
           # GT_freq = `Frequency of GT week`,
           RFT = `Mode minutes  of Remote Family Therapy per week`)
           # RFT_freq = `Frequency of RFT per week`)


## Check to make sure program IDs are coded correctly.

ID_check_natsap <- natsap_sub %>%
    distinct(ID) %>%
    select(company, ID)
ID_check_dose <- dose_sub %>%
    distinct(ID) %>%
    select(company, ID)

ID_check <- inner_join(ID_check_dose, ID_check_natsap, by = "ID")
as.data.frame(ID_check)


## Get complete cases

natsap_sub <- natsap_sub %>%
    na.omit() %>%
    filter(sex != "")
dose_sub <- dose_sub %>%
    na.omit()

## Validity check:
## OQ scores have to be between -16 and 240.

natsap_sub <- natsap_sub %>%
    filter(OQ_A >= -16 & OQ_A <= 240 & OQ_D >= -16 & OQ_D <= 240)

## Join IDs so our tidy data sets will contain only
## programs for which we have dose data and matched pairs.

natsap_tidy <- semi_join(natsap_sub, dose_sub, by = "ID")
dose_tidy <- semi_join(dose_sub, natsap_sub, by = "ID")


## Get sample sizes for each program and keep only programs with more than two 
## matched pairs

sample_size <- natsap_tidy %>%
    group_by(ID) %>%
    summarise(n = n())

dose_tidy <- dose_tidy %>%
    inner_join(sample_size, by = "ID") %>%
    filter(n > 2)

natsap_tidy <- natsap_tidy %>%
    semi_join(dose_tidy, by = "ID")


## Make diff variable

natsap_tidy <- natsap_tidy %>%
    mutate(diff = OQ_A - OQ_D) # Positive scores represent improvement


## Give programs new random ID, consecutively numbered

J <- NROW(dose_tidy)
set.seed(1234)
new_ID <- sample(1:J, J)

dose_tidy <- dose_tidy %>%
    cbind(new_ID) %>%
    arrange(new_ID)

lookup <- dose_tidy %>%
    select(ID, new_ID)

natsap_tidy <- natsap_tidy %>%
    inner_join(lookup, by = "ID") %>%
    arrange(new_ID)

## Write tidy data sets to csv for convenience

 write_csv(dose_tidy, path = "./dose_tidy_1.csv")
 write_csv(natsap_tidy, path = "./natsap_tidy_1.csv")
```

```{r}
## Clean up environment
rm(natsap, dose, natsap_sub, dose_sub, ID_check, ID_check_dose, ID_check_natsap, J, new_ID, lookup, sample_size)
```


## Simple models

### Complete pooling model

Consider `diff` alone. (All programs are averaged together.)

Gather data to pass to Stan:

```{r}
# Model name is 'diff'

data_diff <- list(y = natsap_tidy$diff,
                  n = length(natsap_tidy$diff))
```

Write Stan model:

```{r}
cat("
data {
     int<lower = 1> n;                       // clients
     vector<lower = -256, upper = 256>[n] y; // OQ diffs
 }
 parameters {
     real<lower = -256, upper = 256> mu;
     real<lower = 0> sigma;
 }
 model {
     y ~ normal(mu, sigma);
 }
",
file = "diff.stan")
```

Fit Stan model:

```{r}
final_model = TRUE

if (file.exists("diff.rds") & final_model == TRUE) {
    stan_diff <- readRDS("diff.rds")
} else {
    stan_diff <- stan_model("diff.stan")
    saveRDS(stan_diff, file = "diff.rds")
}

fit_diff <- sampling(stan_diff, data = data_diff)
```

Extract and save samples.

```{r}
samples_diff <- as.data.frame(fit_diff)

write_csv(samples_diff, path = "./diff.csv")

params_diff <- c("mu", "sigma")
```

Show chain diagnostics and posterior summaries.

```{r, fig.width = 9}
traceplot(fit_diff, pars = params_diff, inc_warmup = FALSE)

print(fit_diff)

sample_plots(samples_diff,
             params_diff,
             cred_mass = 0.95,
             layout = matrix(c(1, 2), nrow = 1, ncol = 2))
```

Clean up workspace.

```{r}
cleanup("diff")
```

### No pooling model

Now consider `diff` by program. (In other words, each program is modeled as completely separate from other programs.)

Gather data to pass to Stan:

```{r}
# Model name is 'diff_prog'

data_diff_prog <- list(y = natsap_tidy$diff,
                       n = length(natsap_tidy$diff),
                       J = NROW(dose_tidy),
                       prog = natsap_tidy$new_ID)
```

Write Stan model:

```{r}
cat("
data {
    int<lower = 1> n;                       // clients
    int<lower = 1> J;                       // programs
    vector<lower = -256, upper = 256>[n] y; // OQ diffs
    int prog[n];                            // program for each client
}
parameters {
    vector<lower = -256, upper = 256>[J] mu;
    vector<lower = 0>[J] sigma;
}
model {
    for (i in 1:n) {
        y[i] ~ normal(mu[prog[i]], sigma[prog[i]]);
    }
}
",
file = "diff_prog.stan")
```

Fit Stan model:

```{r}
final_model = TRUE

if (file.exists("diff_prog.rds") & final_model == TRUE) {
    stan_diff_prog <- readRDS("diff_prog.rds")
} else {
    stan_diff_prog <- stan_model("diff_prog.stan")
    saveRDS(stan_diff_prog, file = "diff_prog.rds")
}

fit_diff_prog <- sampling(stan_diff_prog, data = data_diff_prog)
```

Extract and save samples:

```{r}
samples_diff_prog <- as.data.frame(fit_diff_prog)

write_csv(samples_diff_prog, path = "./diff_prog.csv")

# Get 4 random programs
set.seed(4321)
some_programs <- sort(sample(1:data_diff_prog$J, 4))

# Display sample sizes for selected programs.
cat("Sample sizes for programs", some_programs, ": ",
    dose_tidy[dose_tidy$new_ID %in% some_programs,"n"])

# Gather up parameter names
mus <- some_programs %>%
    as.character() %>%
    sapply(function(x) {paste("mu[", x, "]", sep = "")}) %>%
    unname()
sigmas <- some_programs %>%
    as.character() %>%
    sapply(function(x) {paste("sigma[", x, "]", sep = "")}) %>%
    unname()

params_diff_prog <- c(mus, sigmas)
```

Show chain diagnostics and posterior summaries.

```{r, fig.width = 9, fig.height = 10}
traceplot(fit_diff_prog, pars = params_diff_prog, inc_warmup = FALSE)

print(fit_diff_prog)

sample_plots(samples_diff_prog,
             params_diff_prog,
             cred_mass = 0.95,
             layout = matrix(c(1:length(params_diff_prog)),
                             nrow = length(params_diff_prog)/2,
                             ncol = 2))
```

Clean up workspace

```{r}
cleanup("diff_prog")
rm(some_programs, mus, sigmas)
```

```{r}
beep()
```
