---
title: "Reproducing 2014 results in Stan"
author: "Sean Raleigh"
date: "July 8, 2015"
output: html_document
---

To get Stan working, we reproduce the results from the 2014 report, except we convert everything from `lme4` to Stan. (This is Part 1: the file is split up to keep compilation managaeable.)

This part contains the complete pooling and no pooling models.

## Housekeeping

Load necessary libraries and special functions.

```{r, message = FALSE, cache = FALSE}
library(rstan)
library(parallel)
library(beepr)
library(dplyr)
library(ggplot2)
library(knitr)
library(readr)
```

```{r}
source("stan_utilities.R")

## The file stan_utilities.R contains the following functions:

########################################

## stan
## This is a replacement for the stan function in the rstan package that
##      caches already compiled models and runs in parallel if possible.
## Returns a stanfit object.

## stan(stanProgram, optimize = FALSE, cores = parallel::detectCores(), 
##      pedantic = FALSE, sound = 1, ...)

# stanProgram:      Path to .stan file or program string.
#                       (Not required if model_code, file, or fit is present.)
# optimize:         Use sampling() (default) or optimizing().
# cores:            Number of cores to use if sampling().
# pedantic:         Whether to print status messages.
#                       (These messages are dumb. Don't use this.)
# sound:            Sound when sampling complete (if beepr is installed).
#                       (This is fun! Sounds like a kitchen timer.)
# ...               Other arguments passed to Stan:
#                       In this document, we will generally call stan by
#                       passing it a data list and a model code string.
#                       stan(data = data_model, model_code = stan_model)

########################################

## cleanup
## Cleans up the objects left over after fitting a Stan model:
##      data_model:     The data list passed to stan.
##      stan_model:     The model code as a character string.
##      fit_model:      The stanfit object output.
##      samples_model:  The samples as a data frame.
##      params_model:   The parameters to track for plotting.
## Returns nothing.

## cleanup(model)

# model:                Root name of the Stan model as character string.

########################################

## multiplot (winston Chang)
## Places ggplot objects in a grid.
## Returns nothing, but displays desired graphics.

## multiplot(..., plotlist=NULL, file, cols=1, layout=NULL)

# ...               One can pass ggplot objects directly.
#                           (But it's easier to pass them as a plotlist.)
# plotlist:         A list of ggplot objects.
# cols:             Number of columns in layout.
#                       If layout is not specified, multiplot will calculate
#                       how many rows to create using cols.
# layout:           A layout matrix.
#                       For example:
#                           matrix(c(1,2,3,3), nrow=2, byrow=TRUE)
#                       Plot 1 will go in the upper left,
#                       plot 2 will go in the upper right, and
#                       plot 3 will go all the way across the bottom.
#                       If present, cols is ignored.

########################################

## HDIofMCMC (John Kruschke)
## Computes highest density interval from a sample of representative values,
##      estimated as shortest credible interval.

## HDIofMCMC(sampleVec , cred_mass = 0.95)

# sampleVec:        A vector of representative values from a probability distribution.
# cred_mass:        A scalar between 0 and 1, indicating the mass within the credible
#                       interval that is to be estimated.

########################################

## HDI_calc
## Calculates HDI and prepares graphical parameters to pass to ggplot.
## Returns a list of three objects:
##      breaks:     The breaks to use for the histogram.
##      line_pos:   Parameters for plotting the HDI line segments.
##      text_pos:   Parameters for plotting the text annotations.

## HDI_calc(sample, cred_mass = 0.95, digits = 2)

# sample:           A vector of representative values from a probability distribution.
# cred_mass:        A scalar between 0 and 1, indicating the mass within the credible
#                       interval that is to be estimated.
# digits:           The number of decimal places when displaying the HDI.

########################################

## param_plot
## Plots a sampled parameter along with HDI.
## Returns a ggplot object.

## param_plot(sample, param, cred_mass = 0.95)

# sample:           A vector of representative values from a probability distribution.
# param:            A string with the name of the parameters to be plotted.
# cred_mass:        A scalar between 0 and 1, indicating the mass within the credible
#                       interval that is to be estimated.

########################################

## sample_plots
## Creates a grid of histograms of sampled parameters with HDIs.
## Returns nothing, but displays the result of multiplot.

## sample_plots(samples, params, cred_mass = 0.95, layout = NULL)

# samples:          A data frame extracted from a stanfit object.
# params:           A character vector of parameters to be plotted.
# cred_mass:        A scalar between 0 and 1, indicating the mass within the credible
#                       interval that is to be estimated.
# layout:           A layout matrix.
#                       For example:
#                           matrix(c(1,2,3,3), nrow=2, byrow=TRUE)
#                       Plot 1 will go in the upper left,
#                       plot 2 will go in the upper right, and
#                       plot 3 will go all the way across the bottom.
#                       If present, cols is ignored.

########################################

```

## Read and process data

Load data.

```{r, cache = TRUE}
natsap <- read_csv("AllClients_rev3.csv")
dose <- read_csv("DoseData_07-08-2015.csv")
```

Clean data.

```{r, cache = TRUE}

## Subset data

natsap_sub <- natsap %>%
    select(sex = gender,
           ID = programId,
           company = company,
           OQ_A = Z1_A0_Self_SCORE,
           OQ_D = Z1_D0_Self_SCORE)

dose_sub <- dose %>%
    select(company = company,
           ID = NATSAP_ID,
           RTCWT = `RTC or WT`,
           IT = `Mode minutes of Inidividual Therapy per week`,
           # IT_freq = `Frequency of IT per week`,
           GT = `Mode minutes of Group Therapy per week`,
           # GT_freq = `Frequency of GT week`,
           RFT = `Mode minutes  of Remote Family Therapy per week`)
           # RFT_freq = `Frequency of RFT per week`)


## Check to make sure program IDs are coded correctly.

ID_check_natsap <- natsap_sub %>%
    distinct(ID) %>%
    select(company, ID)
ID_check_dose <- dose_sub %>%
    distinct(ID) %>%
    select(company, ID)

ID_check <- inner_join(ID_check_dose, ID_check_natsap, by = "ID")
as.data.frame(ID_check)


## Get complete cases

natsap_sub <- natsap_sub %>%
    na.omit() %>%
    filter(sex != "")
dose_sub <- dose_sub %>%
    na.omit()


## Join IDs so our tidy data sets will contain only
## programs for which we have dose data and matched pairs.

natsap_tidy <- semi_join(natsap_sub, dose_sub, by = "ID")
dose_tidy <- semi_join(dose_sub, natsap_sub, by = "ID")


## Get sample sizes for each program and keep only programs with more than two 
## matched pairs

sample_size <- natsap_tidy %>%
    group_by(ID) %>%
    summarise(n = n())

dose_tidy <- dose_tidy %>%
    inner_join(sample_size, by = "ID") %>%
    filter(n > 2)

natsap_tidy <- natsap_tidy %>%
    semi_join(dose_tidy, by = "ID")


## Make diff variable

natsap_tidy <- natsap_tidy %>%
    mutate(diff = OQ_A - OQ_D) # Positive scores represent improvement


## Give programs new random ID, consecutively numbered

J <- NROW(dose_tidy)
set.seed(1234)
new_ID <- sample(1:J, J)

dose_tidy <- dose_tidy %>%
    cbind(new_ID) %>%
    arrange(new_ID)

lookup <- dose_tidy %>%
    select(ID, new_ID)

natsap_tidy <- natsap_tidy %>%
    inner_join(lookup, by = "ID") %>%
    arrange(new_ID)


## Clean up environment

rm(natsap, dose, natsap_sub, dose_sub, ID_check, ID_check_dose, ID_check_natsap, J, new_ID, lookup, sample_size)
```


## Simple models

### Complete pooling model

Consider `diff` alone. (All programs are averaged together.)

```{r, cache = TRUE}
# Model name is 'diff'

data_diff <- list(y = natsap_tidy$diff,
                  n = length(natsap_tidy$diff))

stan_diff <- "
    data {
        int<lower = 0> n; # clients
        real y[n];
    }
    parameters {
        real mu;
        real<lower = 0> sigma;
    }
    model {
        y ~ normal(mu, sigma);
    }
"

fit_diff <- stan(data = data_diff,
                 model_code = stan_diff)


## Extract samples

samples_diff <- as.data.frame(fit_diff)

params_diff <- c("mu", "sigma")
```

Show chain diagnostics and posterior summaries.

```{r, fig.height= 5}

## Chain diagnostics and posterior summaries.

traceplot(fit_diff, pars = params_diff, inc_warmup = FALSE)

print(fit_diff)

sample_plots(samples_diff,
             params_diff,
             cred_mass = 0.95,
             layout = matrix(c(1, 2), nrow = 1, ncol = 2))
```

Clean up workspace.

```{r}
cleanup("diff")
```

### No pooling model

Now consider `diff` by program. (In other words, each program is modeled as completely separate from other programs.)

```{r, cache = TRUE}
# Model name is 'diff_prog'

data_diff_prog <- list(y = natsap_tidy$diff,
                       n = length(natsap_tidy$diff),
                       J = NROW(dose_tidy),
                       prog = natsap_tidy$new_ID)

stan_diff_prog <- "
    data {
        int<lower = 0> n;   # clients
        int<lower = 0> J;   # programs
        real y[n];          # diff data
        int prog[n];        # program for each client
    }
    parameters {
        real mu[J];
        real<lower = 0> sigma[J];
    }
    model {
        for (i in 1:n) {
            y[i] ~ normal(mu[prog[i]], sigma[prog[i]]);
        }
    }
"

fit_diff_prog <- stan(data = data_diff_prog,
                      model_code = stan_diff_prog)


## Extract samples

samples_diff_prog <- as.data.frame(fit_diff_prog)

# Get 4 random programs
set.seed(4321)
some_programs <- sort(sample(1:data_diff_prog$J, 4))
# Display sample sizes for selected programs.
cat("Sample sizes for programs", some_programs, ": ",
    dose_tidy[dose_tidy$new_ID %in% some_programs,"n"])

# Gather up parameter names
mus <- some_programs %>%
    as.character() %>%
    sapply(function(x) {paste("mu[", x, "]", sep = "")}) %>%
    unname()
sigmas <- some_programs %>%
    as.character() %>%
    sapply(function(x) {paste("sigma[", x, "]", sep = "")}) %>%
    unname()

params_diff_prog <- c(mus, sigmas)

```

Show chain diagnostics and posterior summaries.

```{r, fig.height = 10}

## Chain diagnostics and posterior summary

traceplot(fit_diff_prog, pars = params_diff_prog, inc_warmup = FALSE)

print(fit_diff_prog)

sample_plots(samples_diff_prog,
             params_diff_prog,
             cred_mass = 0.95,
             layout = matrix(c(1:length(params_diff_prog)),
                             nrow = length(params_diff_prog)/2,
                             ncol = 2))
```

Clean up workspace

```{r}
cleanup("diff_prog")
rm(some_programs, mus, sigmas)
```
